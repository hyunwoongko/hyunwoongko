#!/usr/bin/env python
# coding: utf-8

# # 코드 개요

# ### 코드의 정의와 최소 비트
# 코드는 암호화 전/후가 달라야하며, 암호자와 복호자 사이에 일정한 규칙에 의해 생성되어야한다. 규칙이 일정하지 않거나 전/후가 동일하면 그것은 Non-Code라고 부른다. 또한 $2^{(n-1)}$ ~ $2^n$개의 사건을 구분하는 코드를 위해서는 반드시 n개 이상의 비트가 필요하다. (e.g. 9 ~ 16개의 사건 구분에 4개의 비트 필요)

# ### 코드의 형식
# - 다양한 코드의 형식에 대해 알아보자.
# 
# #### Binary Code (이진코드)
# 2진수로 나타낸 코드로 각 자리수에 따라 의미하는 값이 다르게 가중되기 때문에 가중코드라고 부르며, 아래의 코드의 경우는 2-1 코드라고 부른다. (1째 자리는 2, 1째 자리는 1로 가중됨)
# 
# |구분|1째 자리수|2째 자리수|
# |:--:|:--:|:--:|
# |0|0|0|
# |1|0|1|
# |2|1|0|
# |3|1|1|
# 
# #### Excess-n Code (n초과 코드)
# 위의 이진코드의 모든 수에 일정한 숫자 n을 더한 것을 n초과 코드라고 한다. 아래는 모든 수에 1을 더한 1초과 코드이다. n초과 코드는 자리수가 가중치를 갖는다고 볼 수 없으므로 비가중 코드이다.
# 
# |구분|1째 자리수|2째 자리수|
# |:--:|:--:|:--:|
# |0|0|1|
# |1|1|0|
# |2|1|1|
# |3|0|0|
# 
# #### M out of N code
# 항상 N개의 코드중 1의 개수가 M개여야하는 코드로, 항상 1의 개수가 일정해야하기 때문에, 일정하지 않은 경우 오류가 발생한 것으로 간주 할 수 있다. 때문에 이러한 코드를 오류검출코드라고 한다.

# ### 다양한 코드 예시
# 
# #### 8421코드 (BCD코드)
# 10개의 사건을 구분하기 위한 이진코드로 각 자리가 8421의 가중값을 갖기 때문에 8421코드라고 부름. 또한 Binary Code Decimal라는 말로 BCD코드라고도 불린다 (정확히는 8421, 5421, 2421 등의 코드를 통틀어서 BCD코드라고 하는데, 대표적으로 8421코드를 말하기 때문에 거의 BCD=8421처럼 말하기도 한다)
# 
# |구분|8|4|2|1|
# |:--:|:--:|:--:|:--:|:--:|
# |0|0|0|0|0|
# |1|0|0|0|1|
# |2|0|0|1|0|
# |3|0|0|1|1|
# |4|0|1|0|0|
# |5|0|1|0|1|
# |6|0|1|1|0|
# |7|0|1|1|1|
# |8|1|0|0|0|
# |9|1|0|0|1|
# 
# #### 84-2-1코드
# 각 자리수가 8, 4, -2, -1의 가중 값을 갖는 코드이다. 특이한 성질로 정가운데인 4와 5를 기준으로 0과9, 1과8, 2와7 등이 서로 1의 보수의 관계를 갖는다. 이러한 코드를 자기보수코드 (Self Compliemnt Code)라고 부름.
# 
# |구분|8|4|-2|-1|
# |:--:|:--:|:--:|:--:|:--:|
# |0|0|0|0|0|
# |1|0|1|1|1|
# |2|0|1|1|0|
# |3|0|1|0|1|
# |4|0|1|0|0|
# |5|1|0|1|1|
# |6|1|0|1|0|
# |7|1|0|0|1|
# |8|1|0|0|0|
# |9|1|1|1|1|
# 
# #### 2421코드
# 각 자리수가 2, 4, 2, 1의 가중값을 갖는 코드로, 이 코드도 역시 자기보수코드임.
# 
# |구분|2|4|2|1|
# |:--:|:--:|:--:|:--:|:--:|
# |0|0|0|0|0|
# |1|0|0|0|1|
# |2|0|0|1|0|
# |3|0|0|1|1|
# |4|0|1|0|0|
# |5|1|0|1|1|
# |6|1|1|0|0|
# |7|1|1|0|1|
# |8|1|1|1|0|
# |9|1|1|1|1|
# 
# #### 5043210코드
# 5, 0, 4, 3, 2, 1, 0의 가중치를 갖는 코드로, 2 out of 7코드이다. 이 코드는 7개의 자리수에서 항상 1의 개수가 2개로 유지되어야하기 때문에 오류 검출코드로 사용할 수 있다.
# 
# |구분|5|0|4|3|2|1|0|
# |:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
# |0|0|1|0|0|0|0|1|
# |1|0|1|0|0|0|1|0|
# |2|0|1|0|0|1|0|0|
# |3|0|1|0|1|0|0|0|
# |4|0|1|1|0|0|0|0|
# |5|1|0|0|0|0|0|1|
# |6|1|0|0|0|0|1|0|
# |7|1|0|0|0|1|0|0|
# |8|1|0|0|1|0|0|0|
# |9|1|0|1|0|0|0|0|
# 
# #### Excess-3 Code (3초과 코드)
# 84-2-1코드나 2421처럼 자기보수코드이지만 비가중치코드이다. 자기보수코드이면서 2421이나 84-2-1등의 코드보다 덧셈뺄셈 등의 연산이 비교적 간단하기 때문에 보수계산을 위해 쓴다.
# 
# |구분|8|4|2|1|
# |:--:|:--:|:--:|:--:|:--:|
# |0|0|0|1|1|
# |1|0|1|0|0|
# |2|0|1|0|1|
# |3|0|1|1|0|
# |4|0|1|1|1|
# |5|1|0|0|0|
# |6|1|0|0|1|
# |7|1|0|1|0|
# |8|1|0|1|1|
# |9|1|1|0|0|

# ### 3초과 코드의 계산법
# 3초과 코드는 특수한 연산법이 있다. 3이 더해졌기 때문에 이에 대한 처리를 해야한다.
# 
# #### 연산법칙
# - 캐리가 발생하지 않은 아랫자리 → 3을 뺀다
# - 캐리가 발생한 아랫자리 → 3을 더한다.
# - 새롭게 추가된 윗자리 → 3을 더한다.
# 
# #### 연산법칙 해석
# 캐리가 발생하지 않은 자리의 경우, 두 수가 더해질 때 각각 3씩 총 6이 더해진 숫자가 되므로 3을 빼야한다. 캐리가 발생하고 남은 아랫자리의 경우 남은 코드는 8421코드이기 때문에 3을 더해야한다. 새롭게 추가된 자리 역시 0001이 아니라 0100로 올려줘야하기 때문에 3을 더한다.
# 
# #### 계산 예시
# 26 + 88을 계산하면 0101 1001 + 1011 1011을 계산해야한다. 이를 그냥 BCD코드라고 생각하고 계산하면 0001 0001 0100이 된다. 그러나 첫째 4자리와 둘째 4자리에서 모두 캐리가 발생하였고, 새롭게 셋째 4자리가 추가되었으므로, 각 4자리마다 3씩 더해주면 된다. 따라서 0001→0100, 0001→0100, 0100→0111이 되어 최종 결과는 0100 0100 0111 → 114로 잘 계산된다.
# 
# #### 구현

# In[4]:


import re

def preprocessing(a:str):
    """
    숫자를 4의 배수길이로 맞춰주는 함수
    
    자리수를 늘려야 하는 경우 (01) : 00 + 01 = 0001  
    자리수를 늘려야 하는 경우 (11101) : 000 + 11101 = 00011101  
    """
    
    # 빈칸 지우기
    a = re.sub(' ', '', a)
    
    # 길이가 0인경우 엑셉션 발생    
    if len(a) == 0:
        raise Exception() 
    
    # 자리수가 4의 배수가 될때까지 앞에 0을 insert함    
    while len(a) % 4 != 0:
        a = '0' + a[0:]
        
    return a


def split_binary(a:str) -> list:
    """
    00000000처럼 긴 형식을
    0000 0000형식으로 4자리씩 자르는 함수
    """
    
    arr, cache = [], ''
    
    for i, val in enumerate(list(a)):
        cache += val    
        if (i+1) % 4 == 0 and i != 0:
            arr.append(cache)
            cache = ''
    
    return arr


def binary_addition(a:str, b:str)->list:
    """
    두개의 2진수를 더해서 결과를 리턴하는 함수
    덧셈만 구현... 뺄셈까지 구현하기엔 귀찮음 (보수 씁시다 ^^)
    """
    
    a:list = split_binary(preprocessing(a))
    b:list = split_binary(preprocessing(b))
    total, carry = [], 0
    
    # 두 수의 자리수가 안맞으면 맞춰줌
    while len(a) != len(b):
        if len(a) > len(b): b.insert(0, '0000')
        else : a.insert(0, '0000')
    
    a.reverse() # 뒤부터 연산해야하기 때문에 뒤집음
    b.reverse() # 뒤부터 연산해야하기 때문에 뒤집음
    
    for n in zip(a, b):
        a_i = ''.join(reversed(n[0]))
        b_i = ''.join(reversed(n[1]))
        unit = []
        
        for j, m in enumerate(zip(a_i, b_i)):
            a_ij, b_ij = int(m[0]), int(m[1])
            result = a_ij + b_ij + carry
            
            if result >= 2: result -= 2 ; carry = 1
            else: carry = 0
            unit.append(result)
            
            if j == 3:
                unit.reverse()

        total += unit
        
    if carry == 1:
        for i in [0, 0, 0, 1]:
            total.append(i)
        
    total = [str(i) for i in total]
    total = split_binary(''.join(total))
    total.reverse()
    return total


# In[5]:


def excess_3_rule(number, carry):
    
    if carry == 1:
        number = ''.join([str(j) for j in number])
        addition = binary_addition(number, '0011') # 3
        number = [int(j) for j in addition[len(addition) - 1]]
        # 캐리가 발생한 자리는 3을 더함
        
    else:
        number = ''.join([str(j) for j in number])
        addition = binary_addition(number, '1101') # 13
        number = [int(j) for j in addition[len(addition) - 1]]
        # 캐리가 발생하지 않은 자리는 3을 빼야하는데 감산기가 없으므로
        # 보수를 더하고 뒷자리 가져오면 결과 동일 (16진수 => 보수는 13)

    return number


# In[6]:


def excess_3(a:str, b:str)->list:
    """
    3초과코드 계산기
    이전에 구현했던 이진연산 코드를 살짝 변형함
    """
    
    a:list = split_binary(preprocessing(a))
    b:list = split_binary(preprocessing(b))
    total, carry = [], 0
    
    # 두 수의 자리수가 안맞으면 맞춰줌
    while len(a) != len(b):
        if len(a) > len(b): b.insert(0, '0000')
        else : a.insert(0, '0000')
    
    a.reverse() # 뒤부터 연산해야하기 때문에 뒤집음
    b.reverse() # 뒤부터 연산해야하기 때문에 뒤집음
    
    for n in zip(a, b):
        ai = ''.join(reversed(n[0]))
        bi = ''.join(reversed(n[1]))
        unit = []
        
        for j, m in enumerate(zip(ai, bi)):
            aij, bij = int(m[0]), int(m[1])
            result = aij + bij + carry
            
            if result >= 2: 
                result -= 2 ; carry = 1
            else: 
                carry = 0
            
            unit.append(result)
            
            if j == 3:
                unit.reverse()
                unit = excess_3_rule(unit, carry)

        total += unit
        
    if carry == 1:
        # 더할 때 그냥 한번에 4 더해줌 (1 + 3)
        for i in [0, 1, 0, 0]:
            total.append(i)
        
    total = [str(i) for i in total]
    total = split_binary(''.join(total))
    total.reverse()
    return total


print('0101 1001 + 1011 1011 = {}'.format(' '.join(excess_3('01011001', '10111011'))))
print('0100 + 0110 = {}'.format(' '.join(excess_3('0100', '0110'))))


# ### Reference
# > https://youtu.be/kqRKRo4jjQ8
# 
